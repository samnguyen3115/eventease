{% extends "base.html" %} {% block content %}
<h1 style="text-align: center; margin-top: 20px">Event Dashboard</h1>
<div class="event-grid">
  {% for event in events %}
  <div class="event-card" onclick="redirectToChecklist({{ event.id }})" >
    <h2 class="event-name" style="font-size: 24px;color:black">{{ event.name }}</h2>
    <p class="event-date" style="color:rgb(52, 50, 50);">
      <strong>Date:</strong> {{ event.date.strftime('%Y-%m-%d') }}
    </p>

    <!-- Progress Bar -->
    <div class="progress-bar-container">
      <div class="progress-bar">
        <div
          class="progress-bar-fill"
          style="width: {{ event.progress }}%;"
        ></div>
      </div>
    </div>
  </div>
  {% endfor %}
</div>
<script>
  function redirectToChecklist(eventId) {
    // Redirect to the checklist page for the selected event
    window.location.href = `/checklist_detail/${eventId}`;
  }
</script>
<script>
  // Initialize the progress bar
  function initializeProgressBar(card) {
    const checkboxes = card.querySelectorAll('input[type="checkbox"]');
    const progressBarFill = card.querySelector(".progress-bar-fill");

    // Update the progress bar when checkboxes are toggled
    checkboxes.forEach((checkbox) => {
      checkbox.addEventListener("change", () => {
        updateProgressBar(card);
        saveTaskState(checkbox); // Save the checkbox state to the database
      });
    });

    // Initialize the progress bar
    updateProgressBar(card);
  }

  // Update the progress bar
  function updateProgressBar(card) {
    const checkboxes = card.querySelectorAll('input[type="checkbox"]');
    const checked = card.querySelectorAll('input[type="checkbox"]:checked');
    const progress = Math.round((checked.length / checkboxes.length) * 100);

    const progressBarFill = card.querySelector(".progress-bar-fill");
    progressBarFill.style.width = `${progress}%`;
  }

  // Save the checkbox state to the database
  function saveTaskState(checkbox) {
    const taskId = checkbox.value;
    const completed = checkbox.checked;

    // Send an AJAX request to update the task status
    fetch(`/update_task/${taskId}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ completed: completed }),
    })
      .then((response) => {
        if (!response.ok) {
          console.error("Failed to update task status");
        }
      })
      .catch((error) => {
        console.error("Error:", error);
      });
  }

  // Initialize checkbox listeners
  function initializeCheckboxListeners(card, eventId) {
    const checkboxes = card.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach((checkbox) => {
      checkbox.addEventListener("change", () => {
        saveTaskState(checkbox); // Save the checkbox state to the database
        updateProgressBar(card); // Update the progress bar dynamically
      });
    });
  }

  // Initialize inline editing for the event name
  function initializeEditableEventName(card, eventId) {
    const eventNameElement = card.querySelector(".event-name");

    // Add double-click event listener
    eventNameElement.addEventListener("dblclick", () => {
      const currentName = eventNameElement.textContent.trim();
      const input = document.createElement("input");
      input.type = "text";
      input.value = currentName;
      input.classList.add("editable-input");

      // Replace the event name with the input field
      eventNameElement.textContent = "";
      eventNameElement.appendChild(input);
      input.focus();

      // Save changes when the user presses Enter or clicks outside
      const saveChanges = () => {
        const newName = input.value.trim();
        if (newName && newName !== currentName) {
          // Send an AJAX request to update the event name
          fetch(`/update_event_name/${eventId}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ name: newName }),
          })
            .then((response) => {
              if (response.ok) {
                eventNameElement.textContent = newName; // Update the UI
              } else {
                eventNameElement.textContent = currentName; // Revert on failure
                console.error("Failed to update event name");
              }
            })
            .catch((error) => {
              eventNameElement.textContent = currentName; // Revert on error
              console.error("Error:", error);
            });
        } else {
          eventNameElement.textContent = currentName; // Revert if no changes
        }
      };

      // Save changes on blur or Enter key
      input.addEventListener("blur", saveChanges);
      input.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          saveChanges();
        }
      });
    });
  }

  // Initialize inline editing for the event date
  function initializeEditableEventDate(card, eventId) {
    const eventDateElement = card.querySelector(".event-date");

    // Add double-click event listener
    eventDateElement.addEventListener("dblclick", () => {
      const currentDate = eventDateElement.textContent
        .trim()
        .replace("Date: ", "");
      const input = document.createElement("input");
      input.type = "date";
      input.value = currentDate;
      input.classList.add("editable-input");

      // Replace the event date with the input field
      eventDateElement.textContent = "Date: ";
      eventDateElement.appendChild(input);
      input.focus();

      // Save changes when the user presses Enter or clicks outside
      const saveChanges = () => {
        const newDate = input.value.trim();
        if (newDate && newDate !== currentDate) {
          // Send an AJAX request to update the event date
          fetch(`/update_event_date/${eventId}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ date: newDate }),
          })
            .then((response) => {
              if (response.ok) {
                eventDateElement.textContent = `Date: ${newDate}`; // Update the UI
              } else {
                eventDateElement.textContent = `Date: ${currentDate}`; // Revert on failure
                console.error("Failed to update event date");
              }
            })
            .catch((error) => {
              eventDateElement.textContent = `Date: ${currentDate}`; // Revert on error
              console.error("Error:", error);
            });
        } else {
          eventDateElement.textContent = `Date: ${currentDate}`; // Revert if no changes
        }
      };

      // Save changes on blur or Enter key
      input.addEventListener("blur", saveChanges);
      input.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          saveChanges();
        }
      });
    });
  }
  function openEditTaskModal(taskId, description, priority) {
    // Populate the modal with task details
    document.getElementById("editTaskId").value = taskId;
    document.getElementById("editTaskDescription").value = description;
    document.getElementById("editTaskPriority").value = priority;

    // Show the modal
    $("#editTaskModal").modal("show");
  }

  function submitEditTask() {
    const taskId = document.getElementById("editTaskId").value;
    const description = document.getElementById("editTaskDescription").value;
    const priority = document.getElementById("editTaskPriority").value;

    // Send the updated task details to the server
    fetch(`/edit_task/${taskId}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        description: description,
        priority: priority,
      }),
    })
      .then((response) => response.json())
      .then((data) => {
        if (data.success) {
          alert(data.message);
          location.reload(); // Reload the page to reflect changes
        } else {
          alert(data.error);
        }
      })
      .catch((error) => console.error("Error:", error));
  }

  function enableEditTask(taskId) {
    // Hide the text and show the input field and priority dropdown
    const taskText = document.getElementById(`task-text-${taskId}`);
    const taskInput = document.getElementById(`task-input-${taskId}`);
    const taskPriority = document.getElementById(`task-priority-${taskId}`);
    taskText.style.display = "none";
    taskInput.style.display = "inline-block";
    taskPriority.style.display = "inline-block";
    taskInput.focus();

    // Add an event listener to save changes when Enter is pressed
    taskInput.addEventListener("keypress", function (event) {
      if (event.key === "Enter") {
        saveTaskChanges(taskId);
      }
    });

    // Add an event listener to save changes when priority is changed
    taskPriority.addEventListener("change", function () {
      saveTaskChanges(taskId);
    });
  }

  function saveTaskChanges(taskId) {
    const taskInput = document.getElementById(`task-input-${taskId}`);
    const taskPriority = document.getElementById(`task-priority-${taskId}`);
    const newDescription = taskInput.value;
    const newPriority = taskPriority.value;

    // Send the updated task details to the server
    fetch(`/edit_task/${taskId}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        description: newDescription,
        priority: newPriority,
      }),
    })
      .then((response) => response.json())
      .then((data) => {
        if (data.success) {
          // Update the text and hide the input field and priority dropdown
          const taskText = document.getElementById(`task-text-${taskId}`);
          taskText.textContent = newDescription;
          taskText.style.display = "inline-block";
          taskInput.style.display = "none";
          taskPriority.style.display = "none";

          // Optionally update the color based on priority
          if (newPriority == 1) {
            taskText.style.color = "rgb(175, 30, 19)";
          } else if (newPriority == 2) {
            taskText.style.color = "rgb(150, 82, 19)";
          } else {
            taskText.style.color = "";
          }
        } else {
          alert(data.error);
        }
      })
      .catch((error) => console.error("Error:", error));
  }
</script>

{% endblock %}
